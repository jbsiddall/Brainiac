{"mappings":"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","sources":["lib.ts"],"sourcesContent":["import { Database } from 'lmdb'\nimport { equals, mapObjIndexed } from 'ramda'\nimport { z, ZodType } from 'zod'\nimport { v4 as randomId } from 'uuid'\n\n\nconst RECORD_PREFIX = '$'\n\n\nconst baseModelInstanceValidator = z.object({\n  $id: z.string(),\n  $model: z.string(),\n})\n\ntype BaseModelInstanceSchema = typeof baseModelInstanceValidator\n\n\ninterface SchemaModelDefinition<Schema extends BaseModelInstanceSchema = BaseModelInstanceSchema> {\n  schema: Schema,\n}\n\nexport class ModelHelper<M extends SchemaModelDefinition> {\n\n  constructor(private db: Database, private name: string, private model: M) { }\n\n  get(id: string) {\n    return get({ db: this.db, type: this.model, id, name: this.name })\n  }\n\n  put(value: Omit<z.infer<M['schema']>, '$id' | '$model'> & Partial<z.infer<BaseModelInstanceSchema>>) {\n    return put({\n      db: this.db,\n      type: this.model,\n      name: this.name,\n      value: {\n        ...value,\n        $id: value['$id'] ?? randomId(),\n        $model: value['$model'] ?? this.name,\n      }\n    })\n  }\n\n  all() {\n    return all({ db: this.db, model: this.model, name: this.name })\n  }\n}\n\nexport const defineSchema = <Models extends Record<string, SchemaModelDefinition>>(models: Models, options?: { allowUnsafeModelName: boolean }) => ({ db }: { db: Database }) => {\n\n\n  const foo = mapObjIndexed((def, name) => {\n    if (!options?.allowUnsafeModelName && name.includes(RECORD_PREFIX)) {\n      throw new Error(`model ${name} contains illegal characters reserved for ORM '${RECORD_PREFIX}'`)\n    }\n\n    return new ModelHelper(db, name, def)\n\n  }, models)\n\n  return foo as { [K in keyof Models]: ModelHelper<Models[K]> }\n}\n\n\nexport const defineModel = <const Schema extends Record<string, ZodType>>(schema: Schema) => {\n  const unallowedProps = Object.keys(schema).filter(p => p.startsWith(RECORD_PREFIX))\n  if (unallowedProps.length > 0) {\n    throw new Error(`model can't contain any properties that are prefixed with $. found props: ${unallowedProps.join(', ')}`)\n  }\n\n  return {\n    schema: baseModelInstanceValidator.extend(schema),\n  }\n}\n\n\nexport function* all<T extends SchemaModelDefinition>({ db, model, name }: { db: Database, model: T, name: string }) {\n  for (const entry of db.getRange({ start: firstModelKey(name) })) {\n    const baseParseResult = baseModelInstanceValidator.safeParse(entry.value)\n    if (!baseParseResult.success) {\n      /* left the collection range */\n      return\n    }\n    if (baseParseResult.data.$model !== name) {\n      /* left the collection range */\n      return\n    }\n\n    const value = model.schema.parse(entry.value)\n    const key = getKey({ name, id: value.$id })\n    if (!equals(entry.key, key)) {\n      throw new Error(`internal data integrity problem. retriveved model ${name} with key ${String(entry.key)} but expected key was ${key}`)\n    }\n    yield { key, value, version: entry.version }\n  }\n  return\n}\n\nexport const get = <T extends SchemaModelDefinition>({ db, name, type, id }: { db: Database, name: string, type: T, id: string }): undefined | z.infer<T['schema']> => {\n  const key = getKey({ name, id })\n  const value = db.get(key)\n  if (value === undefined) {\n    return undefined\n  }\n  return type.schema.parse(value)\n}\n\nexport const put = <T extends SchemaModelDefinition>({ db, name, type, value }: { db: Database, name: string, type: T, value: z.infer<T['schema']> }) => {\n  const parseResults = type.schema.safeParse(value)\n  if (!parseResults.success) {\n    return { success: false as const, error: parseResults.error, value }\n  }\n\n  const key = getKey({ name, id: value.$id })\n  db.putSync(key, parseResults.data)\n\n  return { success: true as const, error: undefined, value }\n}\n\nconst getKey = ({ name, id }: { name: string, id: string }) => {\n  return [RECORD_PREFIX, name, id]\n}\nconst firstModelKey = (modelName: string) => [RECORD_PREFIX, modelName]\n\n\ninterface Migration {\n  name: string\n  modelsBeforeMigration?: Record<string, SchemaModelDefinition>,\n  modelsAfterMigration?: Record<string, SchemaModelDefinition>,\n  migration: ({ db }: { db: Database }) => void\n}\n\n\nclass MigrationRunner {\n\n  MigrationSchema = defineSchema({\n    [`${RECORD_PREFIX}migrations`]: defineModel({\n      migrationsRun: z.string().array(),\n      modelVersions: z.record(z.string()),\n    })\n  }, { allowUnsafeModelName: true })\n\n  models: ReturnType<typeof this.MigrationSchema>;\n\n  loadRunMigrations() {\n\n    const existing = this.models.$migrations.get('singleton')\n    if (!existing) {\n      const result = this.models.$migrations.put({\n        $id: 'singleton',\n        migrationsRun: [],\n        modelVersions: {}\n      })\n      if (!result.success) {\n        throw new Error('failed to save migrations record')\n      }\n      return result.value\n    }\n    return existing\n  }\n\n  updateRunMigrations(migrationName: string) {\n    const existing = this.loadRunMigrations()!\n\n    this.models.$migrations.put({\n      ...existing,\n      migrationsRun: existing.migrationsRun.concat([migrationName])\n    })\n  }\n\n  constructor(private db: Database, private migrations: Migration[]) {\n    const uniqueMigrationNames = new Set(this.migrations.map(m => m.name))\n    if (uniqueMigrationNames.size !== this.migrations.length) {\n      throw new Error('duplicate migration names')\n    }\n    this.migrations.forEach(m => {\n      if (m.name.trim().length !== m.name.length) {\n        throw new Error(`migration '${m.name}' contains whitespace in name`)\n      }\n      if (m.name.length === 0) {\n        throw new Error('migration with empty space name')\n      }\n    })\n\n    this.models = this.MigrationSchema({ db })\n  }\n\n  run() {\n    const migrationsRun = this.loadRunMigrations()\n\n    const migrationsThatNeedRunning = [] as Migration[]\n\n    for (let i = 0; i < Math.max(migrationsRun.migrationsRun.length, this.migrations.length); i++) {\n      const migrationRun = migrationsRun.migrationsRun.at(i)\n      const definedMigration = this.migrations.at(i)?.name\n\n      if (migrationRun) {\n        if (definedMigration === migrationRun) {\n          continue\n        } else {\n          throw new Error(`migrations previously run is out of order with the migrations provided in code. desprecepency is at index ${i} of hte migrations. Expected ${migrationRun}, got ${definedMigration}`)\n        }\n      } else {\n        if (!definedMigration) {\n          throw new Error('unexpected undefined migration at index ${i}')\n        }\n        migrationsThatNeedRunning.push(this.migrations[i])\n      }\n    }\n\n    for (const migration of migrationsThatNeedRunning) {\n      this.#runMigration(migration)\n    }\n  }\n\n  #runMigration(migration: Migration) {\n    this.db.transactionSync(() => {\n      const migrations = this.loadRunMigrations()\n      if (migrations.migrationsRun.includes(migration.name)) {\n        return\n      }\n\n      if (migration.modelsBeforeMigration) {\n        const models = defineSchema(migration.modelsBeforeMigration)({ db: this.db })\n        Object.keys(migration.modelsBeforeMigration ?? {}).forEach(modelName => {\n\n          for (let entry of models[modelName].all()) {\n            // implicitly validating all model records\n          }\n        })\n      }\n\n\n      migration.migration({ db: this.db })\n\n\n      if (migration.modelsAfterMigration) {\n        const models = defineSchema(migration.modelsAfterMigration)({ db: this.db })\n        Object.keys(migration.modelsAfterMigration ?? {}).forEach(modelName => {\n\n          for (let entry of models[modelName].all()) {\n            // implicitly validating all model records\n          }\n        })\n      }\n\n      this.updateRunMigrations(migration.name)\n    })\n  }\n}\n\nexport function migrate(db: Database, migrations: Migration[]) {\n  const runner = new MigrationRunner(db, migrations)\n  runner.run()\n}\n"],"names":[],"version":3,"file":"lib.js.map"}