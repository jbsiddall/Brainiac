{"mappings":"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","sources":["lib.ts"],"sourcesContent":["import {Database} from 'lmdb'\nimport z, { ZodObject, ZodType } from 'zod'\nimport {equals} from 'ramda'\nimport {v4 as randomId} from 'uuid'\n\n\nconst RECORD_PREFIX = '$'\n\n\nconst baseModelValidator = z.object({\n  $id: z.string(),\n  $model: z.string(),\n})\n\ntype BaseModelSchema = typeof baseModelValidator\n\ninterface Model<Name extends string = string, Schema extends BaseModelSchema = BaseModelSchema> {\n  name: Name\n  schema: Schema\n}\n\nexport class ModelHelper<M extends Model> {\n\n  constructor(private db: Database, private model: M) { }\n\n  get(id: string) {\n    return get({db: this.db, type: this.model, id})\n  }\n\n  put(value: Omit<z.infer<M['schema']>, '$id' | '$model'> & Partial<z.infer<BaseModelSchema>>) {\n    put({\n      db: this.db,\n      type: this.model,\n      value: {\n        ...value,\n        $id: value['$id'] ?? randomId(),\n        $model: value['$model'] ?? this.model.name,\n      }\n    })\n  }\n\n  all() {\n    return all({db: this.db, model: this.model})\n  }\n}\n\n\nexport const defineModel = <Name extends string>({name}: {name: Name}) => <const Schema extends Record<string, ZodType>>(schema: Schema) => {\n  if (name.includes(RECORD_PREFIX)) {\n    throw new Error(`model ${name} contains illegal characters reserved for ORM '${RECORD_PREFIX}'`)\n  }\n\n  const props = Object.keys(schema)\n  if (props.includes('$id') || props.includes('$model')) {\n    throw new Error(`model ${name} can't contain any properties that are prefixed with $`)\n  }\n\n  const base = {\n    name,\n    schema: baseModelValidator.extend(schema),\n  } satisfies Model<Name, any>\n\n  return base\n}\n\nexport function* all<T extends Model>({db, model}: {db: Database, model: T}) {\n  for (const entry of db.getRange({start: firstModelKey(model)})) {\n    const baseParseResult = baseModelValidator.safeParse(entry.value)\n    if (!baseParseResult.success) {\n      /* left the collection range */\n      return\n    }\n    if (baseParseResult.data.$model !== model.name) {\n      /* left the collection range */\n      return\n    }\n\n    const value = model.schema.parse(entry.value)\n    const key  = getKey({model, id: value.$id})\n    if (!equals(entry.key, key)) {\n      throw new Error(`internal data integrity problem. retriveved model ${model.name} with key ${String(entry.key)} but expected key was ${key}`)\n    }\n    yield {key, value, version: entry.version}\n  }\n  return\n}\n\nexport const get = <T extends Model<any, any>>({db, type, id}: {db: Database, type: T, id: string}): z.infer<T['schema']> => {\n  const key = `${type.name}:${id}`\n  const value = db.get(key)\n  return type.schema.parse(value)\n}\n\nexport const put = <T extends Model>({db, type, value}: {db: Database, type: T, value: z.infer<T['schema']>}) => {\n  const parseResults = type.schema.safeParse(value)\n  if (!parseResults.success) {\n    return {success: false, error: parseResults.error}\n  }\n\n  const key = getKey({model: type, id: value.$id})\n  db.putSync(key, parseResults.data)\n\n  return {success: true, error: undefined}\n}\n\nconst getKey = ({model, id}: {model: Model, id: string}) => {\n  return [RECORD_PREFIX, model.name, id]\n}\nconst firstModelKey = (model: Model) => [RECORD_PREFIX, model.name]\n\n\ninterface Migration {\n  name: string\n  modelsBeforeMigration?: Model[]\n  modelsAfterMigration?: Model[]\n  migration: () => void\n}\n\nclass MigrationRunner {\n\n\n  MigrationsRun = z.object({\n    migrationsRun: z.string().array(),\n    modelVersions: z.record(z.string()),\n  })\n  MigrationsRunKey = `${RECORD_PREFIX}${RECORD_PREFIX}migrations`\n\n  constructor(private db: Database, private migrations: Migration[]) {\n    const uniqueMigrationNames = new Set(this.migrations.map(m => m.name))\n    if (uniqueMigrationNames.size !== this.migrations.length) {\n      throw new Error('duplicate migration names')\n    }\n    this.migrations.forEach(m => {\n      if (m.name.trim().length !== m.name.length) {\n        throw new Error(`migration '${m.name}' contains whitespace in name`)\n      }\n      if (m.name.length === 0) {\n        throw new Error('migration with empty space name')\n      }\n    })\n\n    try {\n      this.db.get(this.MigrationsRunKey)\n    } catch (e) {\n      this.db.putSync(this.MigrationsRunKey, {migrationsRun: [], modelVersions: {}} satisfies z.infer<typeof this.MigrationsRun>)\n    }\n  }\n\n  run() {\n    const migrationsRun = this.MigrationsRun.parse(this.db.get(this.MigrationsRunKey))\n\n    const migrationsThatNeedRunning = [] as Migration[]\n\n    for (let i = 0; i < Math.max(migrationsRun.migrationsRun.length, this.migrations.length); i++) {\n      const migrationRun = migrationsRun.migrationsRun.at(i)\n      const definedMigration = this.migrations.at(i)?.name\n\n      if (migrationRun) {\n        if (definedMigration === migrationRun) {\n          continue\n        } else {\n          throw new Error(`migrations previously run is out of order with the migrations provided in code. desprecepency is at index ${i} of hte migrations. Expected ${migrationRun}, got ${definedMigration}`)\n        }\n      } else {\n        if (!definedMigration) {\n          throw new Error('unexpected undefined migration at index ${i}')\n        }\n        migrationsThatNeedRunning.push(this.migrations[i])\n      }\n    }\n\n    for (const migration of migrationsThatNeedRunning) {\n      this.#runMigration(migration)\n    }\n  }\n\n  #runMigration(migration: Migration) {\n    this.db.transactionSync(() => {\n      ;(migration.modelsBeforeMigration ?? []).forEach(model => {\n        const helper = new ModelHelper(this.db, model)\n        for (let entry of helper.all()) {\n          // implicitly validating all model records\n        }\n      })\n\n      migration.migration()\n\n      ;(migration.modelsAfterMigration ?? []).forEach(model => {\n        const helper = new ModelHelper(this.db, model)\n        for (let entry of helper.all()) {\n          // implicitly validating all model records\n        }\n      })\n\n    })\n  }\n\n}\n\nexport function migrate(db: Database, migrations: Migration[]) {\n  const runner = new MigrationRunner(db, migrations)\n  runner.run()\n}\n"],"names":[],"version":3,"file":"lib.js.map"}