{"mappings":";;AASA,QAAA,MAAM;;;;;;;;;EAGJ,CAAA;AAEF,+BAA+B,iCAAiC,CAAA;AAEhE,gBAAgB,IAAI,SAAS,MAAM,GAAG,MAAM,EAAE,MAAM,SAAS,uBAAuB,GAAG,uBAAuB;IAC5G,KAAK,EAAE,IAAI,CAAC;IACZ,MAAM,EAAE,MAAM,CAAC;IACf,MAAM,CAAC,EAAE,EAAE,QAAQ,GAAG,YAAY,MAAM,IAAI,EAAE,MAAM,CAAC,CAAC,CAAA;CACvD;AAED,yBAAyB,CAAC,SAAS,KAAK;gBAElB,EAAE,EAAE,QAAQ,EAAU,KAAK,EAAE,CAAC;QAE9C,EAAE,EAAE,MAAM;QAIV,KAAK,EAAE,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,GAAG,QAAQ,CAAC,GAAG,OAAO,CAAC,EAAE,KAAK,CAAC,uBAAuB,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;CAepG;AAGD,OAAO,MAAM,cAAe,IAAI,SAAS,MAAM,aAAa;IAAE,KAAK,EAAE,IAAI,CAAA;CAAE,YAAY,MAAM,SAAS,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,UAAU,MAAM;;;;;;;;;2WAW5I,CAAA;AAeD,oBAAqB,CAAC,SAAS,KAAK,EAAE,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE;IAAE,EAAE,EAAE,QAAQ,CAAC;IAAC,KAAK,EAAE,CAAC,CAAA;CAAE;;;;;;;kBAoB9E;AAED,OAAO,MAAM,MAAO,CAAC,SAAS,MAAM,GAAG,EAAE,GAAG,CAAC,oBAAoB;IAAE,EAAE,EAAE,QAAQ,CAAC;IAAC,IAAI,EAAE,CAAC,CAAC;IAAC,EAAE,EAAE,MAAM,CAAA;CAAE,KAAG,SAAS,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,CAOvI,CAAA;AAED,OAAO,MAAM,MAAO,CAAC,SAAS,KAAK,uBAAuB;IAAE,EAAE,EAAE,QAAQ,CAAC;IAAC,IAAI,EAAE,CAAC,CAAC;IAAC,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAA;CAAE;;;;;;;;;;;CAU/G,CAAA;AAQD;IACE,IAAI,EAAE,MAAM,CAAA;IACZ,qBAAqB,CAAC,EAAE,KAAK,EAAE,CAAA;IAC/B,oBAAoB,CAAC,EAAE,KAAK,EAAE,CAAA;IAC9B,SAAS,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE;QAAE,EAAE,EAAE,QAAQ,CAAA;KAAE,KAAK,IAAI,CAAA;CAC9C;AAyGD,wBAAwB,EAAE,EAAE,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,QAG5D","sources":["lib.ts"],"sourcesContent":["import { Database } from 'lmdb'\nimport { equals } from 'ramda'\nimport { z, ZodObject, ZodType } from 'zod'\nimport { v4 as randomId } from 'uuid'\n\n\nconst RECORD_PREFIX = '$'\n\n\nconst baseModelInstanceValidator = z.object({\n  $id: z.string(),\n  $model: z.string(),\n})\n\ntype BaseModelInstanceSchema = typeof baseModelInstanceValidator\n\ninterface Model<Name extends string = string, Schema extends BaseModelInstanceSchema = BaseModelInstanceSchema> {\n  model: Name,\n  schema: Schema,\n  helper(db: Database): ModelHelper<Model<Name, Schema>>\n}\n\nexport class ModelHelper<M extends Model> {\n\n  constructor(private db: Database, private model: M) { }\n\n  get(id: string) {\n    return get({ db: this.db, type: this.model, id })\n  }\n\n  put(value: Omit<z.infer<M['schema']>, '$id' | '$model'> & Partial<z.infer<BaseModelInstanceSchema>>) {\n    return put({\n      db: this.db,\n      type: this.model,\n      value: {\n        ...value,\n        $id: value['$id'] ?? randomId(),\n        $model: value['$model'] ?? this.model.model,\n      }\n    })\n  }\n\n  all() {\n    return all({ db: this.db, model: this.model })\n  }\n}\n\n\nexport const defineModel = <Name extends string>({ model }: { model: Name }) => <const Schema extends Record<string, ZodType>>(schema: Schema) => {\n  if (model.includes(RECORD_PREFIX)) {\n    throw new Error(`model ${model} contains illegal characters reserved for ORM '${RECORD_PREFIX}'`)\n  }\n\n  const props = Object.keys(schema)\n  if (props.includes('$id') || props.includes('$model')) {\n    throw new Error(`model ${model} can't contain any properties that are prefixed with $`)\n  }\n\n  return defineModelUnsafe({ model })(schema)\n}\n\nconst defineModelUnsafe = <Name extends string>({ model }: { model: Name }) => <const Schema extends Record<string, ZodType>>(schema: Schema) => {\n  const finalSchema = baseModelInstanceValidator.extend(schema) as any as (BaseModelInstanceSchema & ZodObject<Schema>)\n\n  const definedModel: Model<Name, BaseModelInstanceSchema & ZodObject<Schema>> = {\n    model: model,\n    schema: finalSchema,\n    helper(db) {\n      return new ModelHelper(db, definedModel)\n    }\n  }\n  return definedModel\n}\n\nexport function* all<T extends Model>({ db, model }: { db: Database, model: T }) {\n  for (const entry of db.getRange({ start: firstModelKey(model) })) {\n    const baseParseResult = baseModelInstanceValidator.safeParse(entry.value)\n    if (!baseParseResult.success) {\n      /* left the collection range */\n      return\n    }\n    if (baseParseResult.data.$model !== model.model) {\n      /* left the collection range */\n      return\n    }\n\n    const value = model.schema.parse(entry.value)\n    const key = getKey({ model, id: value.$id })\n    if (!equals(entry.key, key)) {\n      throw new Error(`internal data integrity problem. retriveved model ${model.model} with key ${String(entry.key)} but expected key was ${key}`)\n    }\n    yield { key, value, version: entry.version }\n  }\n  return\n}\n\nexport const get = <T extends Model<any, any>>({ db, type, id }: { db: Database, type: T, id: string }): undefined | z.infer<T['schema']> => {\n  const key = getKey({ model: type, id })\n  const value = db.get(key)\n  if (value === undefined) {\n    return undefined\n  }\n  return type.schema.parse(value)\n}\n\nexport const put = <T extends Model>({ db, type, value }: { db: Database, type: T, value: z.infer<T['schema']> }) => {\n  const parseResults = type.schema.safeParse(value)\n  if (!parseResults.success) {\n    return { success: false as const, error: parseResults.error, value }\n  }\n\n  const key = getKey({ model: type, id: value.$id })\n  db.putSync(key, parseResults.data)\n\n  return { success: true as const, error: undefined, value }\n}\n\nconst getKey = ({ model, id }: { model: Model, id: string }) => {\n  return [RECORD_PREFIX, model.model, id]\n}\nconst firstModelKey = (model: Model) => [RECORD_PREFIX, model.model]\n\n\ninterface Migration {\n  name: string\n  modelsBeforeMigration?: Model[]\n  modelsAfterMigration?: Model[]\n  migration: ({ db }: { db: Database }) => void\n}\n\n\nclass MigrationRunner {\n\n  MigrationModel = defineModelUnsafe({ model: '$migrations' })({\n    migrationsRun: z.string().array(),\n    modelVersions: z.record(z.string()),\n  })\n\n  loadRunMigrations() {\n    const existing = this.MigrationModel.helper(this.db).get('singleton')\n    if (!existing) {\n      const result = this.MigrationModel.helper(this.db).put({\n        $id: 'singleton',\n        migrationsRun: [],\n        modelVersions: {}\n      })\n      if (!result.success) {\n        throw new Error('failed to save migrations record')\n      }\n      return result.value\n    }\n    return existing\n  }\n\n  updateRunMigrations(migrationName: string) {\n    const existing = this.loadRunMigrations()!\n    this.MigrationModel.helper(this.db).put({\n      ...existing,\n      migrationsRun: existing.migrationsRun.concat([migrationName])\n    })\n  }\n\n  constructor(private db: Database, private migrations: Migration[]) {\n    const uniqueMigrationNames = new Set(this.migrations.map(m => m.name))\n    if (uniqueMigrationNames.size !== this.migrations.length) {\n      throw new Error('duplicate migration names')\n    }\n    this.migrations.forEach(m => {\n      if (m.name.trim().length !== m.name.length) {\n        throw new Error(`migration '${m.name}' contains whitespace in name`)\n      }\n      if (m.name.length === 0) {\n        throw new Error('migration with empty space name')\n      }\n    })\n  }\n\n  run() {\n    const migrationsRun = this.loadRunMigrations()\n\n    const migrationsThatNeedRunning = [] as Migration[]\n\n    for (let i = 0; i < Math.max(migrationsRun.migrationsRun.length, this.migrations.length); i++) {\n      const migrationRun = migrationsRun.migrationsRun.at(i)\n      const definedMigration = this.migrations.at(i)?.name\n\n      if (migrationRun) {\n        if (definedMigration === migrationRun) {\n          continue\n        } else {\n          throw new Error(`migrations previously run is out of order with the migrations provided in code. desprecepency is at index ${i} of hte migrations. Expected ${migrationRun}, got ${definedMigration}`)\n        }\n      } else {\n        if (!definedMigration) {\n          throw new Error('unexpected undefined migration at index ${i}')\n        }\n        migrationsThatNeedRunning.push(this.migrations[i])\n      }\n    }\n\n    for (const migration of migrationsThatNeedRunning) {\n      this.#runMigration(migration)\n    }\n  }\n\n  #runMigration(migration: Migration) {\n    this.db.transactionSync(() => {\n      const migrations = this.loadRunMigrations()\n      if (migrations.migrationsRun.includes(migration.name)) {\n        return\n      }\n\n      ; (migration.modelsBeforeMigration ?? []).forEach(model => {\n        const helper = new ModelHelper(this.db, model)\n        for (let entry of helper.all()) {\n          // implicitly validating all model records\n        }\n      })\n\n      migration.migration({ db: this.db })\n\n        ; (migration.modelsAfterMigration ?? []).forEach(model => {\n          const helper = new ModelHelper(this.db, model)\n          for (let entry of helper.all()) {\n            // implicitly validating all model records\n          }\n        })\n\n      this.updateRunMigrations(migration.name)\n    })\n  }\n}\n\nexport function migrate(db: Database, migrations: Migration[]) {\n  const runner = new MigrationRunner(db, migrations)\n  runner.run()\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}